(cl:in-package #:cleavir-ast-transformations)

;;; Cloning an AST is done in two steps.
;;;
;;; In step one, we create a dictionary mapping every node in the
;;; original AST to a cloned node.  The cloned node is created by
;;; calling MAKE-INSTANCE on the class of the original node.  The
;;; initialization arguments passed to MAKE-INSTANCE are obtained from
;;; the SAVE-INFO of the original node, using the same keys and the
;;; same values.  As a result, the slots of the coned node contain
;;; original AST nodes, but also non-AST information such as names,
;;; etc.
;;;
;;; In step two, we iterate over the dictionary entries.  For each
;;; entry, we reinitialize a cloned node by calling
;;; REINITIALIZE-INSTANCE on it.  As with step one, we compute the
;;; initialization arguments to REINITIALIZE-INSTANCE from the
;;; SAVE-INFO, but this time we keep only slot values that are AST
;;; nodes.  Furthermore, we replace each such AST node with the
;;; mapping computed in step one.
(defun clone-ast (ast)
  (let ((dictionary (make-hash-table :test #'eq)))
    (labels
	((traverse (node)
	   (when (null (gethash node dictionary))
	     (setf (gethash node dictionary)
		   (apply #'make-instance (class-of node)
			  (loop for (keyword reader)
				  in (cleavir-io:save-info node)
				collect keyword
				collect (funcall reader node))))
	     (mapc #'traverse (cleavir-ast:children node)))))
      (traverse ast))
    (maphash
     (lambda (key value)
       (apply #'reinitialize-instance
	      value
	      (loop for (keyword reader) in (cleavir-io:save-info key)
		    for new = (gethash (funcall reader key) dictionary)
		    unless (null new)
		      collect keyword
		      and collect new)))
     dictionary)
    (gethash ast dictionary)))

;;; This function is a variation on the cloning.  Instead of directly
;;; computing a clone of an AST, it creates a PROGRAM that, when
;;; executed, creates a clone of the AST.  This feature is useful for
;;; FASL generation.  We can compile the code generated by this
;;; function as part of the FASL so that the AST is generated when the
;;; FASL is loaded.  That way, we can get inline information for
;;; functions loaded from FASL files.
(defun make-create-ast-code (ast)
  (let ((dictionary (make-hash-table :test #'eq)))
    (labels
	((traverse (node)
	   (when (null (gethash node dictionary))
	     (setf (gethash node dictionary) (gensym))
	     (mapc #'traverse (cleavir-ast:children node)))))
      (traverse ast))
    (flet ((init-args-1 (node)
	     (loop for (keyword reader) in (cleavir-io:save-info node)
		   unless (typep (funcall reader node) 'cleavir-ast:ast)
		     collect keyword
		     and collect `',(funcall reader node)))
	   (init-args-2 (node)
	     (loop for (keyword reader) in (cleavir-io:save-info node)
		   when (typep (funcall reader node) 'cleavir-ast:ast)
		     collect keyword
		     and collect (gethash (funcall reader node) dictionary))))
      `(let ,(loop for key being each hash-key of dictionary
		     using (hash-value value)
		   collect `(,value
			     (make-instance
				 ',(class-name key)
			       ,@(init-args-1 key))))
	 ,@(loop for key being each hash-key of dictionary
		   using (hash-value value)
		 collect `(reinitialize-instance
			   ,(gethash value dictionary)
			   ,@(init-args-2 key)))
	 ,(gethash ast dictionary)))))
