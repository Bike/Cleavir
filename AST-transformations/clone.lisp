(cl:in-package #:cleavir-ast-transformations)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Cloning an AST.
;;;
;;; Cloning an AST is done in two steps.
;;;
;;; In step one, we create a dictionary mapping every node in the
;;; original AST to a cloned node.  The cloned node is created by
;;; calling MAKE-INSTANCE on the class of the original node.  The
;;; initialization arguments passed to MAKE-INSTANCE are obtained from
;;; the SAVE-INFO of the original node, using the same keys and the
;;; same values.  As a result, the slots of the coned node contain
;;; original AST nodes, but also non-AST information such as names,
;;; etc.
;;;
;;; In step two, we iterate over the dictionary entries.  For each
;;; entry, we reinitialize a cloned node by calling
;;; REINITIALIZE-INSTANCE on it.  As with step one, we compute the
;;; initialization arguments to REINITIALIZE-INSTANCE from the
;;; SAVE-INFO, but this time we keep only slot values that are AST
;;; nodes.  Furthermore, we replace each such AST node with the
;;; mapping computed in step one.

(defun clone-create-dictionary (ast)
  (let ((dictionary (make-hash-table :test #'eq)))
    (labels ((traverse (node)
	       (when (null (gethash node dictionary))
		 (setf (gethash node dictionary)
		       (make-instance (class-of node)))
		 (mapc #'traverse (cleavir-ast:children node)))))
      (traverse ast))
    dictionary))

(defgeneric finalize-substructure (object dictionary))

(defmethod finalize-substructure (object dictionary)
  (declare (ignore dictionary))
  object)

(defmethod finalize-substructure ((object cons) dictionary)
  (cons (finalize-substructure (car object) dictionary)
	(finalize-substructure (cdr object) dictionary)))

(defmethod finalize-substructure ((object cleavir-ast:ast) dictionary)
  (gethash object dictionary))

(defun finalize (ast model dictionary)
  (apply #'reinitialize-instance
	 ast
	 (loop for (keyword reader) in (cleavir-io:save-info model)
	       for value = (funcall reader model)
	       collect keyword
	       collect (finalize-substructure value dictionary))))

(defun clone-ast (ast)
  (let ((dictionary (clone-create-dictionary ast)))
    (maphash (lambda (key value)
	       (finalize value key dictionary))
	     dictionary)
    (gethash ast dictionary)))

;;; This function is a variation on the cloning.  Instead of directly
;;; computing a clone of an AST, it creates a PROGRAM that, when
;;; executed, creates a clone of the AST.  This feature is useful for
;;; FASL generation.  We can compile the code generated by this
;;; function as part of the FASL so that the AST is generated when the
;;; FASL is loaded.  That way, we can get inline information for
;;; functions loaded from FASL files.
(defun make-create-ast-code (ast)
  (let ((dictionary (make-hash-table :test #'eq)))
    (labels
	((traverse (node)
	   (when (null (gethash node dictionary))
	     (setf (gethash node dictionary) (gensym))
	     (mapc #'traverse (cleavir-ast:children node)))))
      (traverse ast))
    (flet ((init-args-1 (node)
	     (loop for (keyword reader) in (cleavir-io:save-info node)
		   unless (typep (funcall reader node) 'cleavir-ast:ast)
		     collect keyword
		     and collect `',(funcall reader node)))
	   (init-args-2 (node)
	     (loop for (keyword reader) in (cleavir-io:save-info node)
		   when (typep (funcall reader node) 'cleavir-ast:ast)
		     collect keyword
		     and collect (gethash (funcall reader node) dictionary))))
      `(let ,(loop for key being each hash-key of dictionary
		     using (hash-value value)
		   collect `(,value
			     (make-instance
				 ',(class-name (class-of key))
			       ,@(init-args-1 key))))
	 ,@(loop for key being each hash-key of dictionary
		   using (hash-value value)
		 collect `(reinitialize-instance
			   ,(gethash value dictionary)
			   ,@(init-args-2 key)))
	 ,(gethash ast dictionary)))))
