\chapter{Intermediate representation}
\label{chap-ir}

\section{Instruction graph}

The compiler translates an abstract syntax tree into a \emph{graph} of
\emph{instructions}.

This graph is a variation on a \emph{control flow graph}.  As such, it
has a unique instruction called the \emph{initial instruction} which
is the instruction where the execution of the program starts.

In general an instruction can have zero, one, or more
\emph{successors}, and zero, one, or more \emph{predecessors}.

An instruction can also have zero, one, or several \emph{inputs} and
zero, one, or more \emph{outputs}.  An input may be an \emph{constant}
value or a \emph{location} (also called a ``variable'').%
\footnote{The only exception to this rule is that an
  \texttt{enclose-instruction} has an \texttt{enter-instruction} as
  its input.}  An output may only be a location.

There are two types of location: \emph{lexical} locations and \emph{values} locations. The former is used for most instructions, while the latter represents collections of an unknown number of \commonlisp{} values, as output for example by \texttt{funcall} in general.

The execution of an instruction consists of generating the outputs as
a function of the inputs, and also of choosing a successor based on
the inputs.

The execution of a program consists of starting execution at the
\emph{initial instruction} and executing a sequence of instructions
where an instruction in the sequence is the successor chosen during
the execution of the preceding instruction in the sequence.

An instruction graph is said to be \emph{well formed} if and only if
the restrictions on each of the instructions are respected, as defined
in \refSec{sec-ir-instructions}.

It is possible for a well-formed instruction graph to contain
instructions that are not \emph{reachable} in that there is no
execution path from the initial instruction to such an instruction.
This situation can arise as a result of certain optimizations that
determine that a particular successor arc of some instruction can
never be chosen, and so removes that arc.  In certain cases, the
instruction at the head of that arc may then not be reachable from the
initial instruction.

Because of the existence of \texttt{enclose-instruction}s, the concept
of reachability is actually a bit more complicated than what was
hinted in the previous paragraph.  More formally, an instruction is
reachable if and only if:

\begin{itemize}
\item it is an \texttt{enter-instruction}, or
\item it has a reachable predecessor.
\end{itemize}

By stating that every \texttt{enter-instruction} is reachable a
priori, we implicitly assume that the closure generated as the output
of every \texttt{enclose-instruction} is actually \emph{used}.
Whether this is the case or not is of course \emph{undecidable}, but
the translation from an abstract syntax tree to an instruction graph
eliminates some of the cases where the closure may not be used, in
that it does not generate output for anonymous functions that are
evaluated in a context where the resulting closure is obviously not
needed.

An instruction graph program is said to be \emph{reduced} if and only
if it is \emph{well formed} and every instruction is \emph{reachable}.

\section{Levels of detail}

From its initial creation, the instruction graph is transformed in
various ways.  A transformation may add or delete instructions, alter
the predecessor/successor relationship between instructions, or add or
delete inputs or outputs.

Furthermore, some transformations may add new \emph{types} of
instructions that were not present before, and some transformations
may remove all instructions of a particular type.

Globally speaking, however, the instruction graph comes in two major
varieties defined by what types of instructions it contains.  These
two varieties are called \emph{High-level Intermediate Representation}
(or HIR) and \emph{Medium-level Intermediate Representation} (or MIR)
respectively.

\subsection{High-level Intermediate Representation}

At the HIR level, no address calculations are exposed.  All variables
contain \commonlisp{} objects, except that some variables may contain
\emph{unboxed} or \emph{raw} versions of such objects, in particular
integers, floating-point numbers, and characters.

Argument parsing is not exposed, and is instead hidden in a single
\texttt{enter-instruction}.  Similarly, the details of how functions
are called and how values are returned is hidden.  Instructions exist
for accessing the slots of a \texttt{cons} cell, the elements of an
array, and the slots of a standard instance.

The main purpose of restricting the contents variables to
\commonlisp{} objects is that it makes \emph{type inference}
possible.

\subsection{Medium-level Intermediate Representation}

MIR differs from HIR in that real implementation-specific and
backend-specific details are introduced.  The instructions for
accessing slots of a \texttt{cons} cell, elements of an array, or
slots of a standard object, are expanded to expose tagging and address
calculations.

This is the level where most traditional optimizations are
accomplished, such as \emph{value numbering}, \emph{redundancy
  elimination}, \emph{common subexpression elimination}, etc.

\subsection{Low-level Intermediate Representation}

At this level, \emph{registers} and \emph{stack locations} are
introduced according to the conventions for the implementation and the
backend.

This is the level where \emph{register allocation} is accomplished.

\subsection{Compilation policy}

All instructions include a compilation policy \seechap{chap-policy},
specified by the initarg \texttt{:policy} and with accessor
\texttt{policy}. If many instructions are being created at once, the
special variable \texttt{*policy*} can be bound, and will be used
as an initform.

\section{Definition of instructions}
\label{sec-ir-instructions}

\subsection{Instruction \texttt{enter-instruction}}
\label{mir-instruction-enter}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & any\\
\hline
Number of predecessors & 0\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

An instruction of this type is the initial instruction of an
instruction graph.  It is also an input to an
\texttt{enclose-instruction}.  The outputs of this instruction
corresponds to the parameters the function as follows:

\begin{itemize}
\item There is an output for every required parameter.
\item For each optional parameter and for each keyword parameter,
  there are two outputs, one for the parameter itself and one for the
  \texttt{supplied-p} parameter.
\end{itemize}

The execution of this instruction involves parsing the arguments given
to the function, and setting the outputs accordingly.  

The \texttt{enter-instruction} has an accessor named
\texttt{lambda-list}.  The lambda list of this instruction resembles
an ordinary lambda list in that it has a number of required
parameters, possibly a \texttt{\&rest} parameter and some
\texttt{\&optional} and \texttt{\&key} parameters.  It differs from an
ordinary lambda list in the following way:

\begin{itemize}
\item Each required parameter is a \texttt{lexical-location} which is
  also one of the outputs of the instruction.
\item If the \texttt{\&rest} lambda list keyword is present, it is
  followed by a \texttt{lexical-location} which is also one of the
  outputs of the instruction.
\item If the \texttt{\&optional} lambda list keyword is present, it is
  followed by any number of two-element lists.  Each element of each
  such lists is a \texttt{lexical-location} which is also one of the
  outputs of the instruction.  The first element represents the
  argument if it was given and the second element represents a
  \texttt{supplied-p} argument containing either \texttt{nil} or
  \texttt{t}.
\item If the \texttt{\&key} lambda list keyword is present, it is
  followed by any number of three-element lists.  The first element of
  each such list is a \emph{symbol} (typically a symbol in the
  \texttt{keyword} package) used to recognize whether the
  corresponding argument has been given.  The second element and the
  third element of each list is a \texttt{lexical-location} which is
  also one of the outputs of the instruction.  The second element
  represents the argument if it was given and the third element
  represents a \texttt{supplied-p} argument containing either
  \texttt{nil} or \texttt{t}.
\item It does not have any \texttt{\&aux} parameters.
\end{itemize}

Notice that the outputs are lexical locations independently of whether
the parameters to the function are special variables.  The
instructions following the \texttt{enter-instruction} are responsible
for binding special variables and assigning default values to
unsupplied \texttt{\&optional} and \texttt{\&key} parameters.

\refFig{fig-enter-instruction} shows the Graphviz illustration of the
\texttt{enter-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-enter-instruction.pdf_t}
\end{center}
\caption{\label{fig-enter-instruction}
\texttt{enter-instruction}.}
\end{figure}

\subsection{Instruction \texttt{nop-instruction}}
\label{mir-instruction-nop}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

Executing this instruction has no effect.  This instruction may be
introduced by certain transformations as a replacement for existing
instructions.  This way, these transformations do not have to be
concerned with complex updates of the graph.  Instead a dedicated
transformation for removing all \texttt{nop-instruction}s is provided.

\refFig{fig-nop-instruction} shows the Graphviz illustration of the
\texttt{nop-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-nop-instruction.pdf_t}
\end{center}
\caption{\label{fig-nop-instruction}
\texttt{nop-instruction}.}
\end{figure}

\subsection{Instruction \texttt{assignment-instruction}}
\label{mir-instruction-assignment}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The execution of this instruction results in the input being copied to
the output without any modification. 

\refFig{fig-assignment-instruction} shows the Graphviz illustration of the
\texttt{assignment-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-assignment-instruction.pdf_t}
\end{center}
\caption{\label{fig-assignment-instruction}
\texttt{assignment-instruction}.}
\end{figure}

\subsection{Instruction \texttt{funcall-instruction}}
\label{mir-instruction-funcall}

\begin{tabular}{|l|l|}
\hline
Number of inputs & any\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input of this instruction corresponds to the function being
called.  The remaining inputs correspond to the arguments to be passed
to the callee.

The single output of this instruction is a values location,
corresponding to the values returned by the callee.

\refFig{fig-funcall-instruction} shows the Graphviz illustration of the
\texttt{funcall-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-funcall-instruction.pdf_t}
\end{center}
\caption{\label{fig-funcall-instruction}
\texttt{funcall-instruction}.}
\end{figure}

\subsection{Instruction \texttt{funcall-no-return-instruction}}
\label{mir-instruction-funcall-no-return}

\begin{tabular}{|l|l|}
  \hline
  Number of inputs & any\\
  \hline
  Number of outputs & 0\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 0\\
  \hline
\end{tabular}

This instruction is identical to \texttt{funcall-instruction}, except
that the function called is known to execute a non-local control
transfer rather than return normally, e.g. by \texttt{throw} or
\texttt{error}. As such, this instruction has no successors or output.

Use of this instruction rather than \texttt{funcall-instruction}
simplifies analysis of programs, as impossible control paths need not
be analyzed.

\subsection{Instruction \texttt{tailcall-instruction}}
\label{mir-instruction-tailcall}

\begin{tabular}{|l|l|}
\hline
Number of inputs & any\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 0\\
\hline
\end{tabular}

The first input of this instruction corresponds to the function being
called.  The remaining inputs correspond to the arguments to be passed
to the callee.

This instruction can be used instead of a \texttt{funcall-instruction}
immediately followed by a \texttt{return-instruction} such that the
output of the \texttt{funcall-instruction} is the input of the
\texttt{return-instruction}.

\refFig{fig-tailcall-instruction} shows the Graphviz illustration of the
\texttt{tailcall-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-tailcall-instruction.pdf_t}
\end{center}
\caption{\label{fig-tailcall-instruction}
\texttt{tailcall-instruction}.}
\end{figure}

\subsection{Instruction \texttt{return-instruction}}
\label{mir-instruction-return}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 0\\
\hline
\end{tabular}

The input of this instruction is a values location, corresponding to
the values transmitted to the caller.

It terminates execution of the current function and returns to the
caller. 

\refFig{fig-return-instruction} shows the Graphviz illustration of the
\texttt{return-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-return-instruction.pdf_t}
\end{center}
\caption{\label{fig-return-instruction}
\texttt{return-instruction}.}
\end{figure}

\subsection{Instruction \texttt{enclose-instruction}}
\label{mir-instruction-enclose}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input of this instruction is different from those of other
instructions because it is another instruction, namely an
\texttt{enter-instruction}.

The instruction takes the instruction graph of the input and creates a
\emph{closure}.  The closure contains the current lexical runtime
environment and the code resulting from the input instruction graph.

\refFig{fig-enclose-instruction} shows the Graphviz illustration of the
\texttt{enclose-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-enclose-instruction.pdf_t}
\end{center}
\caption{\label{fig-enclose-instruction}
\texttt{enclose-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fdefinition-instruction}}
\label{mir-instruction-fdefinition}

\begin{tabular}{|l|l|}
  \hline
  Number of inputs & 1\\
  \hline
  Number of outputs & 1\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 1\\
  \hline
\end{tabular}

The input is a lexical location holding a function name. The output
is the function with that name in the global environment.

\subsection{Instruction \texttt{eq-instruction}}
\label{mir-instruction-eq}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction are two arbitrary \commonlisp{}
objects.  The first successor is chosen if the values of the inputs
are identical.  Otherwise, the second successor is chosen.

\refFig{fig-eq-instruction} shows the Graphviz illustration of the
\texttt{eq-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-eq-instruction.pdf_t}
\end{center}
\caption{\label{fig-eq-instruction}
\texttt{eq-instruction}.}
\end{figure}

\subsection{Instruction \texttt{car-instruction}}
\label{mir-instruction-car}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a \texttt{cons} cell. The
consequences are undefined if this is not the case.  For that reason,
\emph{safe} code should have additional instructions inserted to
ensure that this condition is respected.  The output is the contents
of the \texttt{car} of the \texttt{cons} cell.

\refFig{fig-car-instruction} shows the Graphviz illustration of the
\texttt{car-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-car-instruction.pdf_t}
\end{center}
\caption{\label{fig-car-instruction}
\texttt{car-instruction}.}
\end{figure}

\subsection{Instruction \texttt{cdr-instruction}}
\label{mir-instruction-cdr}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a \texttt{cons} cell. The
consequences are undefined if this is not the case.  For that reason,
\emph{safe} code should have additional instructions inserted to
ensure that this condition is respected.  The output is the contents
of the \texttt{cdr} of the \texttt{cons} cell.

\refFig{fig-cdr-instruction} shows the Graphviz illustration of the
\texttt{cdr-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-cdr-instruction.pdf_t}
\end{center}
\caption{\label{fig-cdr-instruction}
\texttt{cdr-instruction}.}
\end{figure}

\subsection{Instruction \texttt{rplaca-instruction}}
\label{mir-instruction-rplaca}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \texttt{cons} cell.  The
consequences are undefined if this is not the case.  For that reason,
\emph{safe} code should have additional instructions inserted to
ensure that this condition is respected.  The second input can be any
object.  The effect of the instruction is to replace the contents of
the \texttt{car} of the \texttt{cons} cell by the second input.

\refFig{fig-rplaca-instruction} shows the Graphviz illustration of the
\texttt{rplaca-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-rplaca-instruction.pdf_t}
\end{center}
\caption{\label{fig-rplaca-instruction}
\texttt{rplaca-instruction}.}
\end{figure}

\subsection{Instruction \texttt{rplacd-instruction}}
\label{mir-instruction-rplacd}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \texttt{cons} cell.  The
consequences are undefined if this is not the case.  For that reason,
\emph{safe} code should have additional instructions inserted to
ensure that this condition is respected.  The second input can be any
object.  The effect of the instruction is to replace the contents of
the \texttt{cdr} of the \texttt{cons} cell by the second input.

\refFig{fig-rplacd-instruction} shows the Graphviz illustration of the
\texttt{rplacd-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-rplacd-instruction.pdf_t}
\end{center}
\caption{\label{fig-rplacd-instruction}
\texttt{rplacd-instruction}.}
\end{figure}

\subsection{Instruction \texttt{slot-read-instruction}}
\label{mir-instruction-slot-read}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \emph{standard object},
or some other object with the same structure as a standard object.
The consequences are undefined if this is not the case.  For that
reason, \emph{safe} code should have additional instructions inserted
to ensure that this condition is respected.  The second input is a
non-negative fixnum indicating the \emph{index} of the slot in the
instance.  The output is the contents of the corresponding slot.

\refFig{fig-slot-read-instruction} shows the Graphviz illustration of the
\texttt{slot-read-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-slot-read-instruction.pdf_t}
\end{center}
\caption{\label{fig-slot-read-instruction}
\texttt{slot-read-instruction}.}
\end{figure}

\subsection{Instruction \texttt{slot-write-instruction}}
\label{mir-instruction-slot-write}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 3\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \emph{standard object},
or some other object with the same structure as a standard object.
The consequences are undefined if this is not the case.  For that
reason, \emph{safe} code should have additional instructions inserted
to ensure that this condition is respected.  The second input is a
fixnum indicating the \emph{index} of the slot in the instance.  The
third input can be any object.  The effect of the instruction is to
replace the contents of the corresponding slot by the third input.

\refFig{fig-slot-write-instruction} shows the Graphviz illustration of the
\texttt{slot-write-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-slot-write-instruction.pdf_t}
\end{center}
\caption{\label{fig-slot-write-instruction}
\texttt{slot-write-instruction}.}
\end{figure}

\subsection{Instruction \texttt{aref-instruction}}
\label{mir-instruction-aref}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

This instruction has two additional slots, accessible as follows:

\begin{tabular}{|l|l|l|}
  \hline
  Initarg & Reader & Description\\
  \hline\hline
  \texttt{:element-type} & \texttt{element-type} & Upgraded array element type of array inputs.\\
  \hline
  \texttt{:simple-p} & \texttt{simple-p} & The actual simplicity of array inputs.\\
  \hline
\end{tabular}

The first input to this instruction must be an array with actual
element type and actual simplicity corresponding to that specified in
the instruction slots. The consequences are undefined if this is not
the case.  For that reason, \emph{safe} code should have additional
instructions inserted to ensure that this condition is respected.  The
second input is a non-negative fixnum indicating the \emph{row-major
  index} of an element of the array.  The output is the contents of
the corresponding element of the array.

The output may be \emph{unboxed}, depending on the implementation
and element-type.  If the output is unboxed, it must be used only in
contexts where values of this type are permitted.

\refFig{fig-aref-instruction} shows the Graphviz illustration of the
\texttt{aref-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-aref-instruction.pdf_t}
\end{center}
\caption{\label{fig-aref-instruction}
\texttt{aref-instruction}.}
\end{figure}

\subsection{Instruction \texttt{aset-instruction}}
\label{mir-instruction-aset}

\begin{tabular}{|l|l|}
  \hline
  Number of inputs & 3\\
  \hline
  Number of outputs & 0\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 1\\
  \hline
\end{tabular}

This instruction has two additional slots, accessible as follows:

\begin{tabular}{|l|l|l|}
  \hline
  Initarg & Reader & Description\\
  \hline\hline
  \texttt{:element-type} & \texttt{element-type} & Upgraded array element type of array inputs.\\
  \hline
  \texttt{:simple-p} & \texttt{simple-p} & The actual simplicity of array inputs.\\
  \hline
\end{tabular}

The first input to this instruction must be an array with actual
element type and actual simplicity corresponding to that specified
in the instruction slots. The consequences are undefined if this is
not the case.  For that reason,
\emph{safe} code should have additional instructions inserted to
ensure that this condition is respected.
 safe code should insert additional instructions to
ensure it. The second input is a non-negative fixnum indicating the
\emph{row-major index} of an element of the array. The third input
is the object to be written into the array. There are no outputs.

The object to be written into the array may be \emph{unboxed}, depending
on the implementation and element-type.

\subsection{Instruction \texttt{fixnum-add-instruction}}
\label{mir-instruction-fixnum-add}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If
the program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is a
\texttt{fixnum}.

If the first successor is chosen, then the output is the sum of the
two inputs.

If the second successor is chosen, then the sum of the inputs is not
possible to represent as a fixnum, so in order to obtain the sum of
the two inputs, the following adjustment has to be made:

\begin{itemize}
\item If the output is negative, then $2^n$ must be added to the
  output, where $n$ is the number of bits used to represent a fixnum. 
\item If the output is positive, then $2^n$ must be subtracted from
  the output, where $n$ is the number of bits used to represent a
  fixnum.
\end{itemize}

The second successor is typically a \texttt{funcall-instruction} to
some function that accomplishes this adjustment and returns a bignum.

\refFig{fig-fixnum-add-instruction} shows the Graphviz illustration of the
\texttt{fixnum-add-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-add-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-add-instruction}
\texttt{fixnum-add-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-sub-instruction}}
\label{mir-instruction-fixnum-sub}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If
the program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is a
\texttt{fixnum}.

If the first successor is chosen, then the output is the difference
between the two inputs.

If the second successor is chosen, then the difference between the
inputs is not possible to represent as a fixnum, so in order to obtain
the difference between the two inputs, the following adjustment has to
be made:

\begin{itemize}
\item If the output is negative, then $2^n$ must be added to the
  output, where $n$ is the number of bits used to represent a fixnum. 
\item If the output is positive, then $2^n$ must be subtracted from
  the output, where $n$ is the number of bits used to represent a
  fixnum.
\end{itemize}

The second successor is typically a \texttt{funcall-instruction} to
some function that accomplishes this adjustment and returns a bignum.

\refFig{fig-fixnum-sub-instruction} shows the Graphviz illustration of the
\texttt{fixnum-sub-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-sub-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-sub-instruction}
\texttt{fixnum-sub-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-less-instruction}}
\label{mir-instruction-fixnum-less}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If
the program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is
strictly less than the second input.

\refFig{fig-fixnum-less-instruction} shows the Graphviz illustration of the
\texttt{fixnum-less-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-less-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-less-instruction}
\texttt{fixnum-less-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-not-greater-instruction}}
\label{mir-instruction-fixnum-le}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If
the program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is
less than or equal to the second input.

\refFig{fig-fixnum-le-instruction} shows the Graphviz illustration of the
\texttt{fixnum-not-greater-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-le-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-le-instruction}
\texttt{fixnum-not-greater-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-equal-instruction}}
\label{mir-instruction-fixnum-equal}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If
the program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is equal
to the second input.

\refFig{fig-fixnum-equal-instruction} shows the Graphviz illustration of the
\texttt{fixnum-equal-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-equal-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-equal-instruction}
\texttt{fixnum-equal-instruction}.}
\end{figure}

\subsection{Instruction \texttt{phi-instruction}}
\label{mir-instruction-phi}

\begin{tabular}{|l|l|}
\hline
Number of inputs & > 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

This instruction is used for variables respecting the \emph{static
  single assignment} (SSA) property.  

One of the following must hold for any \texttt{phi-instruction} A:

\begin{itemize}
\item The number of predecessors of A is equal to the number of inputs
  to A, or
\item A has a single predecessor B, and B is also a
  \texttt{phi-instruction} with the same number of inputs as A.
\end{itemize}

In other words, \texttt{phi-instruction}s occur in \emph{clusters}
with the same number of inputs $n$.  The first instruction of such a
cluster has $n$ predecessors, and the others have a single
predecessor. 

Special care must be taken when the graph is modified so that this
restriction is respected. 

\refFig{fig-phi-instruction} shows the Graphviz illustration of the
\texttt{phi-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-phi-instruction.pdf_t}
\end{center}
\caption{\label{fig-phi-instruction}
\texttt{phi-instruction}.}
\end{figure}

Some transformations may be easier to accomplish if there is a single
\texttt{phi-instruction} as opposed to a cluster of several such
instructions.  We may propose a \emph{cluster/uncluster}
transformation on the entire program so that both representations are
accessible. 

\subsection{Instruction \texttt{use-instruction}}
\label{mir-instruction-use}

\begin{tabular}{|l|l|}
\hline
Number of inputs &  1\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

This instruction is similar to the \texttt{nop-instruction} in that it
does nothing.  The difference is that this instruction takes a single
input, is a lexical variable.  The purpose is to create an artificial
use for the input so that it will be kept alive until after this
instruction is encountered.  An instance of this instruction class
will typically be emitted when the \texttt{debug} optimization quality has a high value.

\subsection{Instruction \texttt{typeq-instruction}}
\label{mir-instruction-typeq}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

This instruction has a slot, with initarg \texttt{:value-type} and
reader \texttt{value-type}. It is a \commonlisp{} type specifier.

The first input of this instruction is an object of which the type
is be tested.

The first successor is chosen if and only if the first input is of
the type stored in the instruction.

This instruction is used in a variety of situations:

\begin{itemize}
\item When the source code contains a call to \texttt{typep} with a
  constant type argument, a compiler macro might transform the call to
  a special form that generates this instruction.
\item Some implementations might generate this instruction from the
  special operator \texttt{the}, where the second successor contains a
  call to \texttt{error}.
\item Since type declarations can be seen as implicit use of the
  special operator \texttt{the}, this instruction can be used for type
  declarations as well.
\item The macro \texttt{check-type} might result in this instruction
  being generated, in which case the second successor would contain
  instructions to signal a correctable error.
\end{itemize}

\refFig{fig-typeq-instruction} shows the Graphviz illustration of the
\texttt{typeq-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-typeq-instruction.pdf_t}
\end{center}
\caption{\label{fig-typeq-instruction}
\texttt{typeq-instruction}.}
\end{figure}

\subsection{Instruction \texttt{the-instruction}}
\label{mir-instruction-the}

\begin{tabular}{|l|l|}
  \hline
  Number of inputs & 1\\
  \hline
  Number of outputs & 0\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 1\\
  \hline
\end{tabular}

There is a single slot, usable with initarg \texttt{:value-type} and
reader \texttt{value-type}.

This instruction is similar to the \texttt{typeq-instruction}. It is
different in that it has no operational effect and does not branch.
It exists only to inform the compiler that its input has been declared
to be a particular type.

It is possible for an implementation to enable \emph{safe code} by
transforming this instruction into \texttt{typeq} with an error
branch.

It is possible for an implementation to remove all instances of this
instruction from the instruction graph after type inference has been
completed (or at any time, if there is no type inference).

\subsection{Instruction \texttt{the-values-instruction}}
\label{mir-instruction-the-values}
\begin{tabular}{|l|l|}
  \hline
  Number of inputs & 1\\
  \hline
  Number of outputs & 0\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 1\\
  \hline
\end{tabular}

This instruction has several extra slots, as follows:

\begin{tabular}{|l|l|l|}
  \hline
  Initarg & Reader & Description\\
  \hline\hline
  \texttt{:required-types} & \texttt{required-types} & An ordered list of required types for the values.\\
  \hline
  \texttt{:optional-types} & \texttt{optional-types} & An ordered list of \optional types for the values.\\
  \hline
  \texttt{:rest-type} & \texttt{rest-type} & The \rest type for the values.\\
  \hline
\end{tabular}

This instruction is similar to \texttt{the-instruction}, with the
difference that its input is a values location, and that it
represents a values type. It is used only in contexts where a values
location is needed as an input (e.g., \texttt{return-instruction}s).

Like \texttt{cleavir-ast:the-ast}, the type specified does not have
the implicit \rest behavior of \texttt{cl:the}.

\subsection{Instruction \texttt{multiple-to-fixed-instruction}}
\label{mir-instruction-multiple-to-fixed}

\begin{tabular}{|l|l|}
  \hline
  Number of inputs & 1\\
  \hline
  Number of outputs & any\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 1\\
  \hline
\end{tabular}

This instruction converts a values location to zero or more lexical
locations. It is used in contexts where a fixed number of values is
expected but an unknown number of values is provided, such as the
result of a call (unknown values) being used as an argument to a
function (one value).

If fewer ordinary lexical locations are required than there are values
contained in the values location, then the remaining values are
ignored. If more ordinary lexical locations are required than there
are values contained in the values location, then the remaining
ordinary lexical locations are assigned the value \texttt{nil}.

This instruction's name is sometimes abbreviated ``M->F''.

\subsection{Instruction \texttt{fixed-to-multiple-instruction}}
\label{mir-instruction-fixed-to-multiple}

\begin{tabular}{|l|l|}
  \hline
  Number of inputs & any\\
  \hline
  Number of outputs & 1\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 1\\
  \hline
\end{tabular}

This instruction converts zero or more lexical locations into a single
values location. It is used in context where a fixed number of values
is provided but an unknown number of values is required, e.g. a
lexical variable access (one value) being the return value of a
function (unknown values).

This instruction's name is sometimes abbreviated ``F->M''.

\subsection{Instruction \texttt{multiple-value-call-instruction}}
\label{mir-instruction-multiple-value-call}

\begin{tabular}{|l|l|}
  \hline
  Number of inputs & any\\
  \hline
  Number of outputs & 1\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 1\\
  \hline
\end{tabular}

This instruction represents the full generality of
\texttt{cl:multiple-value-call}, i.e. a call where the number of
values in the arguments is not known statically. The first input is
a lexical location, the callee. The remainder are values locations,
the arguments. The output is a values location.

Because this instruction is more involved than
\texttt{funcall-instruction}, implementations should endeavor to
avoid its use where possible, and convert
\texttt{cl:multiple-value-call} into \texttt{funcall-instruction}s
instead.

\subsection{Instruction \texttt{symbol-value-instruction}}
\label{mir-instruction-symbol-value}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a symbol naming a special
variable.  The output is the value of that special variable.

\subsection{Instruction \texttt{set-symbol-value-instruction}}
\label{mir-instruction-set-symbol-value}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a symbol naming a
special variable.  The second input can be any object.  The effect of
the instruction is to replace the current value of the special
variable the second input.

\subsection{Instruction \texttt{box-instruction}}
\label{mir-instruction-box}

\begin{tabular}{|l|l|}
  \hline
  Number of inputs & 1\\
  \hline
  Number of outputs & 1\\
  \hline
  Number of predecessors & any\\
  \hline
  Number of successors & 1\\
  \hline
\end{tabular}

This instruction has one extra slot, usable with initarg
\texttt{:element-type} and accessor \texttt{element-type}.

The input to this instruction must be an unboxed value of the type
specified by the \texttt{element-type} of the instruction.

The output is a boxed value corresponding to the input.

\subsection{Instruction \texttt{unbox-instruction}}
\label{mir-instruction-unbox}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

This instruction has one extra slot, usable with initarg
\texttt{:element-type} and accessor \texttt{element-type}.

The input to this instruction must be a boxed value of the type
specified by the \texttt{element-type} of the instruction.

The output is an unboxed value corresponding to the input.

\subsection{Instruction \texttt{float-add-instruction}}
\label{mir-instruction-float-add}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}.  If the program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The output is also
of type unboxed short float.

The output is the sum of the two inputs.

\refFig{fig-float-add-instruction} shows the Graphviz illustration of the
\texttt{float-add-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-add-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-add-instruction}
\texttt{float-add-instruction}.}
\end{figure}

\subsection{Instruction \texttt{float-sub-instruction}}
\label{mir-instruction-float-sub}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}. The output is also of type unboxed short float.

The output is the difference between the two inputs.

\refFig{fig-float-sub-instruction} shows the Graphviz illustration of the
\texttt{float-sub-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-sub-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-sub-instruction}
\texttt{float-sub-instruction}.}
\end{figure}

\subsection{Instruction \texttt{float-mul-instruction}}
\label{mir-instruction-float-mul}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}. The output is also of type unboxed short float.

The output is the product of the two inputs.

\refFig{fig-float-mul-instruction} shows the Graphviz illustration of the
\texttt{float-mul-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-mul-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-mul-instruction}
\texttt{float-mul-instruction}.}
\end{figure}

\subsection{Instruction \texttt{float-div-instruction}}
\label{mir-instruction-float-div}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}. The output is also of type unboxed short float.

The output is the quotient of the two inputs.

\refFig{fig-float-div-instruction} shows the Graphviz illustration of the
\texttt{float-div-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-div-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-div-instruction}
\texttt{float-div-instruction}.}
\end{figure}

\subsection{Instruction \texttt{float-less-instruction}}
\label{mir-instruction-float-less}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}.

The first successor is chosen if the first input is strictly less than
the second one; otherwise the second successor is chosen. 

\refFig{fig-float-less-instruction} shows the Graphviz illustration of the
\texttt{float-less-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-less-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-less-instruction}
\texttt{float-less-instruction}.}
\end{figure}

\subsection{Instruction \texttt{float-not-greater-instruction}}
\label{mir-instruction-float-not-greater}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \emph{unboxed short
  float}.

The first successor is chosen if the first input is less than or equal
to the second one; otherwise the second successor is chosen.

\refFig{fig-float-not-greater-instruction} shows the Graphviz illustration of the
\texttt{float-not-greater-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-not-greater-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-not-greater-instruction}
\texttt{float-not-greater-instruction}.}
\end{figure}

\subsection{Instruction \texttt{float-sin-instruction}}
\label{mir-instruction-float-div}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be of type \emph{unboxed short
  float}. The output is also of type unboxed short float.

The output is the sine of the input.

\refFig{fig-float-sin-instruction} shows the Graphviz illustration of the
\texttt{float-sin-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-sin-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-sin-instruction}
\texttt{float-sin-instruction}.}
\end{figure}

\subsection{Instruction \texttt{float-cos-instruction}}
\label{mir-instruction-float-div}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be of type \emph{unboxed short
  float}. The output is also of type unboxed short float.

The output is the cosine of the input.

\refFig{fig-float-cos-instruction} shows the Graphviz illustration of the
\texttt{float-cos-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-cos-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-cos-instruction}
\texttt{float-cos-instruction}.}
\end{figure}

\subsection{Instruction \texttt{float-sqrt-instruction}}
\label{mir-instruction-float-div}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be of type \emph{unboxed short
  float}. The output is also of type unboxed short float.

The output is the square root of the input.

\refFig{fig-float-sqrt-instruction} shows the Graphviz illustration of the
\texttt{float-sqrt-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-float-sqrt-instruction.pdf_t}
\end{center}
\caption{\label{fig-float-sqrt-instruction}
\texttt{float-sqrt-instruction}.}
\end{figure}

\subsection{Instruction \texttt{create-cell-instruction}}
\label{mir-instruction-create-cell}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

This instruction creates a \emph{cell} to be used as part of the
captured static environment of a closure.  The exact nature of the
cell that is created is not specified.  Most implementations would
probably just return a \texttt{cons} cell since \texttt{cons} cells
already exist.

\subsection{Instruction \texttt{fetch-instruction}}
\label{mir-instruction-fetch}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

This instruction is used when the static environment is represented as
a single vector containing an entry for each closed-over variable.
Such an entry is either a \emph{cell} (with unspecified
representation) if the corresponding variable is modified, or the
entry can be the variable itself if it is not modified.

This instruction takes two inputs.  The first input is a dynamic
lexical location that holds the static environment.  The second input
is an immediate input containing a non-negative integer and which
serves as an index into the static environment.  This instruction has
a single output, which is a dynamic lexical location.

\subsection{Instruction \texttt{read-cell-instruction}}
\label{mir-instruction-read-cell}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

Since the structure of a cell holding the value of a closed-over
variable is unspecified, we use this instruction to obtain the value
held in such a cell.

This instruction takes a single input, namely a dynamic lexical
location holding the cell to be read from.  This instruction has a
single output, namely a dynamic lexical location to hold the value of
the variable.

\subsection{Instruction \texttt{write-cell-instruction}}
\label{mir-instruction-write-cell}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

Since the structure of a cell holding the value of a closed-over
variable is unspecified, we use this instruction to write the value
held in such a cell.

This instruction takes two inputs. The first input is a dynamic
lexical location holding the cell to be written to.  The second input
is a constant input or a dynamic lexical input holding the value to
write to the cell.  This instruction has no outputs.

\section{Data}

\subsection{Input \texttt{constant-input}}

This data type corresponds to constants in source code.  It can only
be used as an \emph{input}.

The slot reader \texttt{value} can be used to access the constant. 

\refFig{fig-constant-input} shows the Graphviz illustration of the
\texttt{constant-input}

\begin{figure}
\begin{center}
\inputfig{fig-constant-input.pdf_t}
\end{center}
\caption{\label{fig-constant-input}
\texttt{constant-input}.}
\end{figure}

\subsection{Location \texttt{lexical-location}}

This data type corresponds to lexical variable in the source code, and
to temporary variables introduced by the compiler.  It can be used
both as an input and as an output.

The slot reader \texttt{name} can be used to access the name of the
variables.  Notice that different lexical locations have different
\emph{identity} (i.e, they are not \texttt{eq}), but several different
lexical locations may have the same name, due to shadowing.

\refFig{fig-lexical-location} shows the Graphviz illustration of the
\texttt{lexical-location}

\begin{figure}
\begin{center}
\inputfig{fig-lexical-location.pdf_t}
\end{center}
\caption{\label{fig-lexical-location}
\texttt{lexical-location}.}
\end{figure}

\subsection{Location \texttt{values-location}}

This data type corresponds to locations where an unknown number of
values, in the \commonlisp{} sense, exist. An example of this is
the return values from a call to an unknown function.

Values locations can be used as both inputs and outputs, but are
more restricted than lexical locations. Fewer instructions accept or
output them, and they cannot be assigned.

Because values locations are usually very temporary, there is no
need for them to have names.

% Probably could use a figure for this one, at least!

\subsection{Location \texttt{simple-location}}

This data type corresponds is a subtype of \texttt{lexical-location}.
It is used for lexical locations that are referred to within a single
function, so that there is no possible capture.  A location of this
type can be allocated in a register or on the stack.  A temporary
variable introduced by the compiler will always turn into a datum of
this type.

\refFig{fig-simple-location} shows the Graphviz illustration of the
\texttt{simple-location}

\begin{figure}
\begin{center}
\inputfig{fig-simple-location.pdf_t}
\end{center}
\caption{\label{fig-simple-location}
\texttt{simple-location}.}
\end{figure}

\subsection{Location \texttt{shared-location}}

This data type corresponds is a subtype of \texttt{lexical-location}.
It is used for lexical locations that are referred to from several
function, i.e., for \emph{shared} variables.  A location of this
type can \emph{not} be allocated in a register or on the stack.
Instead, it has to be allocated in the \emph{static runtime
  environment}. 

\refFig{fig-shared-location} shows the Graphviz illustration of the
\texttt{shared-location}

\begin{figure}
\begin{center}
\inputfig{fig-shared-location.pdf_t}
\end{center}
\caption{\label{fig-shared-location}
\texttt{shared-location}.}
\end{figure}

\section{Operations on intermediate code}

\subsection{Cloning an instruction}

\Defgeneric {clone-instruction} {instruction}

This function creates a copy of \textit{instruction}.

\Defmethod {clone-instruction} {(instruction {\tt instruction})}

The primary method creates an instance of the class of
\textit{instruction}, with the same inputs, outputs and successors
(the lists are not copied). 

Client code must create \texttt{:after} methods to fill in additional
slots. 

\Defun {insert-instruction-before} {new existing}

Insert the instruction \textit{new} before the instruction
\textit{existing}.  After this operation \textit{new} will have
\textit{existing} as its sole successor, and \textit{existing} will
have \textit{new} as its sole predecessor.  For every instruction $p$
that was a predecessor of \textit{existing} before this operation was
executed, after the operation $p$ will be a predecessor of
\textit{new} and \textit{new} will have replaced \textit{existing} as
a successor of $p$.

\Defun {insert-instruction-between} {new existing1 existing2}

Insert the instruction \textit{new} between the instructions
\textit{existing1} and \textit{existing2}, where \textit{existing2} is
a successor of \textit{existing1}.  \textit{existing1} can have any
number of successors and \textit{existing2} can have any number of
predecessors.  \textit{existing1} becomes the sole predecessor of
\textit{new} and \textit{existing2} becomes the sole successor of
\textit{new}.  \textit{new} replaces \textit{existing2} as a successor
of \textit{existing1}, and \textit{existing1} as a predecessor of
\textit{existing2}.

\Defun {insert-instruction-after} {new existing}

Insert \textit{new} after \textit{existing}.  \textit{existing} must
have a single successor.  The effect is to insert \textit{new} between
\textit{existing} and its sole successor.

\Defun {delete-instruction} {instruction}

Delete \textit{instruction}.  \textit{instruction} must have a single
successor.  The sole successor of \textit{instruction} replaces
\textit{instruction} as the successor of every predecessor of
\textit{instruction}.  The predecessors of \textit{instruction} become
the predecessors of the sole successor of \textit{instruction}.

\Defun {bypass-instruction} {instruction successor}

This function is used to delete unnecessary branches.
\textit{instruction} is an instruction with at least one successor,
and \textit{successor} is one of those successors. \textit{instruction}
is deleted, and all predecessors to \textit{instruction} replace
\textit{instruction} in their successors with \textit{successor}.
\textit{successor} likewise has the predecessors of \textit{instruction}
added to its predecessors.

%%  LocalWords:  optimizations reachability unsupplied callee runtime
%%  LocalWords:  subtype backend unboxed
