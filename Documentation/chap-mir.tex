\chapter{Medium-level intermediate representation}
\label{chap-mir}

The compiler translates an abstract syntax tree into a \emph{graph} of
\emph{instructions} in a language named \emph{MIR}.  This graph is a
variation on a \emph{control flow graph}.  As such, it has a unique
instruction called the \emph{initial instruction} which is the
instruction where the execution of the MIR program starts. 

In general an instruction can have zero, one, or more
\emph{successors}, and zero, one, or more \emph{predecessors}.

An instruction can also have zero, one, or several \emph{inputs} and
zero, one, or more \emph{outputs}.  An input may be an \emph{constant}
value or a \emph{lexical variable}.%
\footnote{The only exception to this rule is that an
  \texttt{enclose-instruction} has an \texttt{enter-instruction} as
  its input.}  An output may only be a lexical variable.

The execution of a a MIR instruction consists of generating the
outputs as a function of the inputs, and also of choosing a successor
based on the inputs.

The execution of a MIR program consists of starting execution at the
\emph{initial instruction} and executing a sequence of instructions
where an instruction in the sequence is the successor chosen during
the execution of the preceding instruction in the sequence.

A MIR program is said to be \emph{well formed} if and only if the
restrictions on each of the instructions are respected, as defined in
\refSec{sec-mir-instructions}.

It is possible for a well-formed MIR program to contain instructions
that are not \emph{reachable} in that there is no execution path from
the initial instruction to such an instruction.  This situation can
arise as a result of certain optimizations that determine that a
particular successor arc of some instruction can never be chosen, and
so removes that arc.  In certain cases, the instruction at the head of
that arc may then not be reachable from the initial instruction.  

Because of the existence of \texttt{enclose-instruction}s, the concept
of reachability is actually a bit more complicated than what was
hinted in the previous paragraph.  More formally, an instruction is
reachable if and only if:

\begin{itemize}
\item it is an \texttt{enter-instruction}, or
\item it has a reachable predecessor.
\end{itemize}

By stating that every \texttt{enter-instruction} is reachable a
priori, we implicitly assume that the closure generated as the output
of every \texttt{enclose-instruction} is actually \emph{used}.
Whether this is the case or not is of course \emph{undecidable}, but
the translation from an abstract syntax tree to MIR eliminates some of
the cases where the closure may not be used, in that it does not
generate output for anonymous functions that are evaluated in a
context where the resulting closure is obviously not needed.

A MIR program is said to be \emph{reduced} if and only if it is
\emph{well formed} and every instruction is \emph{reachable}. 

\section{Definition of MIR instructions}
\label{sec-mir-instructions}

\subsection{Instruction \texttt{enter-instruction}}
\label{mir-instruction-enter}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & any\\
\hline
Number of predecessors & 0\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

An instruction of this type is either the initial instruction of a MIR
program, or an input to an \texttt{enclose-instruction}.  The outputs
of this instruction corresponds to the parameters the function as
follows: 

\begin{itemize}
\item There is an output for every required parameter.
\item For each optional parameter and for each keyword parameter,
  there are two outputs, one for the parameter itself and one for the
  \texttt{supplied-p} parameter.
\end{itemize}

The execution of this instruction involves parsing the arguments given
to the function, and setting the outputs accordingly.  

This instruction has an accessor named \texttt{lambda-list}.  The
lambda list of the \texttt{enter-instruction} resembles an ordinary
lambda list in that it has a number of required parameters, possibly a
\texttt{\&rest} parameter and some \texttt{\&optional} and
\texttt{\&key} parameters.  It differs from an ordinary lambda list in
the following way:

\begin{itemize}
\item Each required parameter is a \texttt{lexical-location} which is
  also one of the outputs of the instruction.
\item If the \texttt{\&rest} lambda list keyword is present, it is
  followed by a \texttt{lexical-location} which is also one of the
  outputs of the instruction.
\item If the \texttt{\&optional} lambda list keyword is present, it is
  followed by any number of two-element lists.  Each element of each
  such lists is a \texttt{lexical-location} which is also one of the
  outputs of the instruction.  The first element represents the
  argument if it was given and the second element represents a
  \texttt{supplied-p} argument containing either \texttt{nil} or
  \texttt{t}.
\item If the \texttt{\&key} lambda list keyword is present, it is
  followed by any number of three-element lists.  The first element of
  each such list is a \emph{symbol} (typically a symbol in the
  \texttt{keyword} package) used to recognize whether the
  corresponding argument has been given.  The second element and the
  third element of each list is a \texttt{lexical-location} which is
  also one of the outputs of the instruction.  The second element
  represents the argument if it was given and the third element
  represents a \texttt{supplied-p} argument containing either
  \texttt{nil} or \texttt{t}.
\end{itemize}

Notice that the outputs are lexical locations independently of whether
the parameters to the function are special variables.  The MIR
instructions following the \texttt{enter-instruction} are responsible
for binding special variables and assigning default values to
unsupplied \texttt{\&optional} and \texttt{\&key} parameters.

\refFig{fig-enter-instruction} shows the Graphviz illustration of the
\texttt{enter-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-enter-instruction.pdf_t}
\end{center}
\caption{\label{fig-enter-instruction}
\texttt{enter-instruction}.}
\end{figure}

\subsection{Instruction \texttt{nop-instruction}}
\label{mir-instruction-nop}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

Executing this instruction has no effect. 

\refFig{fig-nop-instruction} shows the Graphviz illustration of the
\texttt{nop-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-nop-instruction.pdf_t}
\end{center}
\caption{\label{fig-nop-instruction}
\texttt{nop-instruction}.}
\end{figure}

\subsection{Instruction \texttt{assignment-instruction}}
\label{mir-instruction-assignment}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The execution of this instruction results in the input being copied to
the output without any modification. 

\refFig{fig-assignment-instruction} shows the Graphviz illustration of the
\texttt{assignment-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-assignment-instruction.pdf_t}
\end{center}
\caption{\label{fig-assignment-instruction}
\texttt{assignment-instruction}.}
\end{figure}

\subsection{Instruction \texttt{funcall}}
\label{mir-instruction-funcall}

This instruction has a single successor.  It can have any number of
inputs, and it has no outputs.  The inputs correspond to the function
to call and to the arguments of that function.

\subsection{Instruction \texttt{get-values}}
\label{mir-instruction-get-values}

This instruction has a single successor.  It has no inputs and it can
have any number of outputs.

The effect of this instruction is to assign the values of a preceding
function call to a set of lexical variables. 

\subsection{Instruction \texttt{return}}
\label{mir-instruction-return}

This instruction has no successors.  It can have any number of
inputs, and it has no outputs.  The inputs correspond to the values
transmitted to the caller

It terminates execution of the current function and returns to the
caller. 

\subsection{Instruction \texttt{enclose}}
\label{mir-instruction-enclose}

This instruction has a single successor.  It has a single output. 
It does have an input, but it is a special one because it is not a
value, but instead the root of an instruction graph.  

The instruction takes the instruction graph and creates a
\emph{closure}.  The closure contains the current lexical runtime
environment and the code resulting from the input instruction graph.

%%  LocalWords:  optimizations reachability unsupplied
