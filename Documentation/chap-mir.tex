\chapter{Medium-level intermediate representation}
\label{chap-mir}

The compiler translates an abstract syntax tree into a \emph{graph} of
\emph{instructions} in a language named \emph{MIR}.  This graph is a
variation on a \emph{control flow graph}.  As such, it has a unique
instruction called the \emph{initial instruction} which is the
instruction where the execution of the MIR program starts. 

In general an instruction can have zero, one, or more
\emph{successors}, and zero, one, or more \emph{predecessors}.

An instruction can also have zero, one, or several \emph{inputs} and
zero, one, or more \emph{outputs}.  An input may be an \emph{constant}
value or a \emph{lexical variable}.%
\footnote{The only exception to this rule is that an
  \texttt{enclose-instruction} has an \texttt{enter-instruction} as
  its input.}  An output may only be a lexical variable.

The execution of a a MIR instruction consists of generating the
outputs as a function of the inputs, and also of choosing a successor
based on the inputs.

The execution of a MIR program consists of starting execution at the
\emph{initial instruction} and executing a sequence of instructions
where an instruction in the sequence is the successor chosen during
the execution of the preceding instruction in the sequence.

A MIR program is said to be \emph{well formed} if and only if the
restrictions on each of the instructions are respected, as defined in
\refSec{sec-mir-instructions}.

It is possible for a well-formed MIR program to contain instructions
that are not \emph{reachable} in that there is no execution path from
the initial instruction to such an instruction.  This situation can
arise as a result of certain optimizations that determine that a
particular successor arc of some instruction can never be chosen, and
so removes that arc.  In certain cases, the instruction at the head of
that arc may then not be reachable from the initial instruction.  

Because of the existence of \texttt{enclose-instruction}s, the concept
of reachability is actually a bit more complicated than what was
hinted in the previous paragraph.  More formally, an instruction is
reachable if and only if:

\begin{itemize}
\item it is an \texttt{enter-instruction}, or
\item it has a reachable predecessor.
\end{itemize}

By stating that every \texttt{enter-instruction} is reachable a
priori, we implicitly assume that the closure generated as the output
of every \texttt{enclose-instruction} is actually \emph{used}.
Whether this is the case or not is of course \emph{undecidable}, but
the translation from an abstract syntax tree to MIR eliminates some of
the cases where the closure may not be used, in that it does not
generate output for anonymous functions that are evaluated in a
context where the resulting closure is obviously not needed.

A MIR program is said to be \emph{reduced} if and only if it is
\emph{well formed} and every instruction is \emph{reachable}. 

\section{Definition of MIR instructions}
\label{sec-mir-instructions}

\subsection{Instruction \texttt{enter-instruction}}
\label{mir-instruction-enter}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & any\\
\hline
Number of predecessors & 0\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

An instruction of this type is either the initial instruction of a MIR
program, or an input to an \texttt{enclose-instruction}.  The outputs
of this instruction corresponds to the parameters the function as
follows: 

\begin{itemize}
\item There is an output for every required parameter.
\item For each optional parameter and for each keyword parameter,
  there are two outputs, one for the parameter itself and one for the
  \texttt{supplied-p} parameter.
\end{itemize}

The execution of this instruction involves parsing the arguments given
to the function, and setting the outputs accordingly.  

This instruction has an accessor named \texttt{lambda-list}.  The
lambda list of the \texttt{enter-instruction} resembles an ordinary
lambda list in that it has a number of required parameters, possibly a
\texttt{\&rest} parameter and some \texttt{\&optional} and
\texttt{\&key} parameters.  It differs from an ordinary lambda list in
the following way:

\begin{itemize}
\item Each required parameter is a \texttt{lexical-location} which is
  also one of the outputs of the instruction.
\item If the \texttt{\&rest} lambda list keyword is present, it is
  followed by a \texttt{lexical-location} which is also one of the
  outputs of the instruction.
\item If the \texttt{\&optional} lambda list keyword is present, it is
  followed by any number of two-element lists.  Each element of each
  such lists is a \texttt{lexical-location} which is also one of the
  outputs of the instruction.  The first element represents the
  argument if it was given and the second element represents a
  \texttt{supplied-p} argument containing either \texttt{nil} or
  \texttt{t}.
\item If the \texttt{\&key} lambda list keyword is present, it is
  followed by any number of three-element lists.  The first element of
  each such list is a \emph{symbol} (typically a symbol in the
  \texttt{keyword} package) used to recognize whether the
  corresponding argument has been given.  The second element and the
  third element of each list is a \texttt{lexical-location} which is
  also one of the outputs of the instruction.  The second element
  represents the argument if it was given and the third element
  represents a \texttt{supplied-p} argument containing either
  \texttt{nil} or \texttt{t}.
\end{itemize}

Notice that the outputs are lexical locations independently of whether
the parameters to the function are special variables.  The MIR
instructions following the \texttt{enter-instruction} are responsible
for binding special variables and assigning default values to
unsupplied \texttt{\&optional} and \texttt{\&key} parameters.

\refFig{fig-enter-instruction} shows the Graphviz illustration of the
\texttt{enter-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-enter-instruction.pdf_t}
\end{center}
\caption{\label{fig-enter-instruction}
\texttt{enter-instruction}.}
\end{figure}

\subsection{Instruction \texttt{nop-instruction}}
\label{mir-instruction-nop}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 0\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

Executing this instruction has no effect. 

\refFig{fig-nop-instruction} shows the Graphviz illustration of the
\texttt{nop-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-nop-instruction.pdf_t}
\end{center}
\caption{\label{fig-nop-instruction}
\texttt{nop-instruction}.}
\end{figure}

\subsection{Instruction \texttt{assignment-instruction}}
\label{mir-instruction-assignment}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The execution of this instruction results in the input being copied to
the output without any modification. 

\refFig{fig-assignment-instruction} shows the Graphviz illustration of the
\texttt{assignment-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-assignment-instruction.pdf_t}
\end{center}
\caption{\label{fig-assignment-instruction}
\texttt{assignment-instruction}.}
\end{figure}

\subsection{Instruction \texttt{funcall-instruction}}
\label{mir-instruction-funcall}

\begin{tabular}{|l|l|}
\hline
Number of inputs & any\\
\hline
Number of outputs & any\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input of this instruction corresponds to the function being
called.  It can be either a lexical location or a global-input.  
The remaining inputs correspond to the arguments to be passed to the
callee. 

The outputs of this instruction correspond to the values that the
caller requests from the callee.  The number of outputs can therefore
be different from the actual number of values produced by the caller.

\refFig{fig-funcall-instruction} shows the Graphviz illustration of the
\texttt{funcall-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-funcall-instruction.pdf_t}
\end{center}
\caption{\label{fig-funcall-instruction}
\texttt{funcall-instruction}.}
\end{figure}

\subsection{Instruction \texttt{tailcall-instruction}}
\label{mir-instruction-tailcall}

\begin{tabular}{|l|l|}
\hline
Number of inputs & any\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 0\\
\hline
\end{tabular}

The first input of this instruction corresponds to the function being
called.  It can be either a lexical location or a global-input.  
The remaining inputs correspond to the arguments to be passed to the
callee. 

\refFig{fig-tailcall-instruction} shows the Graphviz illustration of the
\texttt{tailcall-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-tailcall-instruction.pdf_t}
\end{center}
\caption{\label{fig-tailcall-instruction}
\texttt{tailcall-instruction}.}
\end{figure}

\subsection{Instruction \texttt{return-instruction}}
\label{mir-instruction-return}

\begin{tabular}{|l|l|}
\hline
Number of inputs & any\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 0\\
\hline
\end{tabular}

The inputs of this instruction correspond to the values transmitted to
the caller

It terminates execution of the current function and returns to the
caller. 

\refFig{fig-return-instruction} shows the Graphviz illustration of the
\texttt{return-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-return-instruction.pdf_t}
\end{center}
\caption{\label{fig-return-instruction}
\texttt{return-instruction}.}
\end{figure}

\subsection{Instruction \texttt{enclose-instruction}}
\label{mir-instruction-enclose}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input of this instruction is different from those of other
instructions because it is another instruction, namely an
\texttt{enter-instruction}.

The instruction takes the instruction graph of the input and creates a
\emph{closure}.  The closure contains the current lexical runtime
environment and the code resulting from the input instruction graph.

\refFig{fig-enclose-instruction} shows the Graphviz illustration of the
\texttt{enclose-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-enclose-instruction.pdf_t}
\end{center}
\caption{\label{fig-enclose-instruction}
\texttt{enclose-instruction}.}
\end{figure}

\subsection{Instruction \texttt{test-instruction}}
\label{mir-instruction-test}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The input of this instruction is a generalized Boolean.  The first
successor is chosen if the value of the input is \emph{true} and the
second successor is chosen of the value of the input is \emph{false}.

\refFig{fig-test-instruction} shows the Graphviz illustration of the
\texttt{test-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-test-instruction.pdf_t}
\end{center}
\caption{\label{fig-test-instruction}
\texttt{test-instruction}.}
\end{figure}

\subsection{Instruction \texttt{car-instruction}}
\label{mir-instruction-car}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a \texttt{cons} cell.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is the contents of
the \texttt{car} of the \texttt{cons} cell.

\refFig{fig-car-instruction} shows the Graphviz illustration of the
\texttt{car-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-car-instruction.pdf_t}
\end{center}
\caption{\label{fig-car-instruction}
\texttt{car-instruction}.}
\end{figure}

\subsection{Instruction \texttt{cdr-instruction}}
\label{mir-instruction-cdr}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a \texttt{cons} cell.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is the contents of
the \texttt{cdr} of the \texttt{cons} cell.

\refFig{fig-cdr-instruction} shows the Graphviz illustration of the
\texttt{cdr-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-cdr-instruction.pdf_t}
\end{center}
\caption{\label{fig-cdr-instruction}
\texttt{cdr-instruction}.}
\end{figure}

\subsection{Instruction \texttt{rplaca-instruction}}
\label{mir-instruction-rplaca}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \texttt{cons} cell.  If
the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input
can be any object.  The effect of the instruction is to replace the
contents of the \texttt{car} of the \texttt{cons} cell by the second
input.

\refFig{fig-rplaca-instruction} shows the Graphviz illustration of the
\texttt{rplaca-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-rplaca-instruction.pdf_t}
\end{center}
\caption{\label{fig-rplaca-instruction}
\texttt{rplaca-instruction}.}
\end{figure}

\subsection{Instruction \texttt{rplacd-instruction}}
\label{mir-instruction-rplacd}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \texttt{cons} cell.  If
the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input
can be any object.  The effect of the instruction is to replace the
contents of the \texttt{cdr} of the \texttt{cons} cell by the second
input.

\refFig{fig-rplacd-instruction} shows the Graphviz illustration of the
\texttt{rplacd-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-rplacd-instruction.pdf_t}
\end{center}
\caption{\label{fig-rplacd-instruction}
\texttt{rplacd-instruction}.}
\end{figure}

\subsection{Instruction \texttt{slot-read-instruction}}
\label{mir-instruction-slot-read}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \emph{standard object}.
If the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input is
a non-negative fixnum indicating the \emph{index} of the slot in the
instance.  The output is the contents of the corresponding slot.

\refFig{fig-slot-read-instruction} shows the Graphviz illustration of the
\texttt{slot-read-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-slot-read-instruction.pdf_t}
\end{center}
\caption{\label{fig-slot-read-instruction}
\texttt{slot-read-instruction}.}
\end{figure}

\subsection{Instruction \texttt{slot-write-instruction}}
\label{mir-instruction-slot-write}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 3\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a \emph{standard object}.
If the MIR program is \emph{safe}, then control must reach this
instruction only if this restriction is verified.  The second input is
a fixnum indicating the \emph{index} of the slot in the instance.  The
third input can be any object.  The effect of the instruction is to
replace the contents of the corresponding slot by the third input.

\refFig{fig-slot-write-instruction} shows the Graphviz illustration of the
\texttt{slot-write-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-slot-write-instruction.pdf_t}
\end{center}
\caption{\label{fig-slot-write-instruction}
\texttt{slot-write-instruction}.}
\end{figure}

\subsection{Instruction \texttt{aref-instruction}}
\label{mir-instruction-aref}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be an \emph{array}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The second input is a
non-negative fixnum indicating the \emph{row-major index} of an
element of the array.  The output is the contents of the corresponding
element of the array.

\refFig{fig-aref-instruction} shows the Graphviz illustration of the
\texttt{aref-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-aref-instruction.pdf_t}
\end{center}
\caption{\label{fig-aref-instruction}
\texttt{aref-instruction}.}
\end{figure}

\subsection{Instruction \texttt{aset-instruction}}
\label{mir-instruction-aset}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 3\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be an \emph{array}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The second input is a fixnum
indicating the \emph{row-major index} of an element of the array.
The third input can be any object.  The effect of the instruction is
to replace the contents of the corresponding element by the third input.

\refFig{fig-aset-instruction} shows the Graphviz illustration of the
\texttt{aset-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-aset-instruction.pdf_t}
\end{center}
\caption{\label{fig-aset-instruction}
\texttt{aset-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-+-instruction}}
\label{mir-instruction-fixnum-+}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is a
\texttt{fixnum}.  

If the first successor is chosen, then the output is
the sum of the two inputs.  

If the second successor is chosen, then in order to obtain the sum of the
two inputs, the following adjustment has to be made:

\begin{itemize}
\item If the output is negative, then $2^n$ must be added to the
  output, where $n$ is the number of bits used to represent a fixnum. 
\item If the output is positive, then $2^n$ must be subtracted from
  the output, where $n$ is the number of bits used to represent a
  fixnum.
\end{itemize}

\refFig{fig-fixnum-+-instruction} shows the Graphviz illustration of the
\texttt{fixnum-+-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-+-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-+-instruction}
\texttt{fixnum-+-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum---instruction}}
\label{mir-instruction-fixnum-+}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.  The output is a
\texttt{fixnum}.  

If the first successor is chosen, then the output is
the difference between the two inputs.  

If the second successor is chosen, then in order to obtain the difference
between the two inputs, the following adjustment has to be made:

\begin{itemize}
\item If the output is negative, then $2^n$ must be added to the
  output, where $n$ is the number of bits used to represent a fixnum. 
\item If the output is positive, then $2^n$ must be subtracted from
  the output, where $n$ is the number of bits used to represent a
  fixnum.
\end{itemize}

\refFig{fig-fixnum---instruction} shows the Graphviz illustration of the
\texttt{fixnum---instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum---instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum---instruction}
\texttt{fixnum---instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-<-instruction}}
\label{mir-instruction-fixnum-less}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is
strictly less than the second input.

\refFig{fig-fixnum-less-instruction} shows the Graphviz illustration of the
\texttt{fixnum-<-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-less-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-less-instruction}
\texttt{fixnum-<-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-<=-instruction}}
\label{mir-instruction-fixnum-le}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is
less than or equal to the second input.

\refFig{fig-fixnum-le-instruction} shows the Graphviz illustration of the
\texttt{fixnum-<=-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-le-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-le-instruction}
\texttt{fixnum-<=-instruction}.}
\end{figure}

\subsection{Instruction \texttt{fixnum-=-instruction}}
\label{mir-instruction-fixnum-equal}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The inputs to this instruction must be of type \texttt{fixnum}.  If the
MIR program is \emph{safe}, then control must reach this instruction
only if this restriction is verified.

The first successor is chosen if and only if the first input is equal
to the second input.

\refFig{fig-fixnum-equal-instruction} shows the Graphviz illustration of the
\texttt{fixnum-=-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-fixnum-equal-instruction.pdf_t}
\end{center}
\caption{\label{fig-fixnum-equal-instruction}
\texttt{fixnum-=-instruction}.}
\end{figure}

\subsection{Instruction \texttt{phi-instruction}}
\label{mir-instruction-phi}

\begin{tabular}{|l|l|}
\hline
Number of inputs & > 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

This instruction is used for variables respecting the \emph{static
  single assignment} (SSA) property.  

One of the following must hold for any \texttt{phi-instruction} A:

\begin{itemize}
\item The number of predecessors of A is equal to the number of inputs
  to A, or
\item A has a single predecessor B, and B is also a
  \texttt{phi-instruction} with the same number of inputs as A.
\end{itemize}

In other words, \texttt{phi-instruction}s occur in \emph{clusters}
with the same number of inputs $n$.  The first instruction of such a
cluster has $n$ predecessors, and the others have a single
predecessor. 

Special care must be taken when the graph is modified so that this
restriction is respected. 

\refFig{fig-phi-instruction} shows the Graphviz illustration of the
\texttt{phi-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-phi-instruction.pdf_t}
\end{center}
\caption{\label{fig-phi-instruction}
\texttt{phi-instruction}.}
\end{figure}

\subsection{Instruction \texttt{typeq-instruction}}
\label{mir-instruction-typeq}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 2\\
\hline
\end{tabular}

The first input of this instruction is an object of which the type
is be tested.  The second input is a \emph{type specifier}.
Initially, the second input is a \texttt{constant-input}, but that
might change as a result of transformations of the graph.  

The first successor is chosen if and only if the first input is of the
type denoted by the second input. 

This instruction is used in a variety of situations:

\begin{itemize}
\item When the source code contains a call to \texttt{typep} with a
  constant type argument, a compiler macro might transform the call to
  a special form that generates this instruction.
\item Some implementations might generate this instruction from the
  special operator \texttt{the}, where the second successor contains a
  call to \texttt{error}.
\item Since type declarations can be seen as implicit use of the
  special operator \texttt{the}, this instruction can be used for type
  declarations as well.
\item The macro \texttt{check-type} might result in this instruction
  being generated, in which case the second successor would contain
  instructions to signal a correctable error.
\end{itemize}

Because the second input may not be a \texttt{constant-input}, the
type specifier can also be retrieved using the slot reader
\texttt{value-type}. 

\refFig{fig-typeq-instruction} shows the Graphviz illustration of the
\texttt{typeq-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-typeq-instruction.pdf_t}
\end{center}
\caption{\label{fig-typeq-instruction}
\texttt{typeq-instruction}.}
\end{figure}

\subsection{Instruction \texttt{sref-instruction}}
\label{mir-instruction-sref}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 1\\
\hline
Number of outputs & 1\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The input to this instruction must be a constant symbol naming a
special variable.  The output is the value of that special variable.

\refFig{fig-sref-instruction} shows the Graphviz illustration of the
\texttt{sref-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-sref-instruction.pdf_t}
\end{center}
\caption{\label{fig-sref-instruction}
\texttt{sref-instruction}.}
\end{figure}

\subsection{Instruction \texttt{sset-instruction}}
\label{mir-instruction-sset}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a constant symbol naming a
special variable.  The second input can be any object.  The effect of
the instruction is to replace the current value of the special
variable the second input.

\refFig{fig-sset-instruction} shows the Graphviz illustration of the
\texttt{sset-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-sset-instruction.pdf_t}
\end{center}
\caption{\label{fig-sset-instruction}
\texttt{sset-instruction}.}
\end{figure}

\subsection{Instruction \texttt{sbind-instruction}}
\label{mir-instruction-sbind}

\begin{tabular}{|l|l|}
\hline
Number of inputs & 2\\
\hline
Number of outputs & 0\\
\hline
Number of predecessors & any\\
\hline
Number of successors & 1\\
\hline
\end{tabular}

The first input to this instruction must be a constant symbol naming a
special variable.  The second input can be any object.  The effect of
the instruction is to create a new binding for the special variable,
where the initial value is that of the second input.

The binding is automatically destroyed when the current function
invocation terminates by executing a \texttt{return-instruction}.
After an instruction of this type has been executed, control flow must
not be able to reach a \texttt{tailcall-instruction}. 

\refFig{fig-sbind-instruction} shows the Graphviz illustration of the
\texttt{sbind-instruction}

\begin{figure}
\begin{center}
\inputfig{fig-sbind-instruction.pdf_t}
\end{center}
\caption{\label{fig-sbind-instruction}
\texttt{sbind-instruction}.}
\end{figure}

\section{Data}

\subsection{Input \texttt{constant-input}}

This data type corresponds to constants in source code.  It can only
be used as an \emph{input}.

The slot reader \texttt{value} can be used to access the constant. 

\refFig{fig-constant-input} shows the Graphviz illustration of the
\texttt{constant-input}

\begin{figure}
\begin{center}
\inputfig{fig-constant-input.pdf_t}
\end{center}
\caption{\label{fig-constant-input}
\texttt{constant-input}.}
\end{figure}

%%  LocalWords:  optimizations reachability unsupplied callee runtime
