(cl:in-package #:cleavir-hir-transformations)

(defgeneric maybe-eliminate (instruction))

(defmethod maybe-eliminate (instruction)
  (declare (ignore instruction))
  nil)

(defmethod maybe-eliminate ((instruction cleavir-ir:typeq-instruction))
  (let* ((object (first (cleavir-ir:inputs instruction)))
	 (typep-constant (cleavir-ir:make-constant-input 'typep))
	 (typep-function (cleavir-ir:new-temporary))
	 (fdefinition (cleavir-ir:make-fdefinition-instruction
		       typep-constant typep-function))
	 (type (cleavir-ir:value-type instruction))
	 (type-descriptor-constant (cleavir-ir:make-constant-input type))
	 (boolean-value (cleavir-ir:new-temporary))
	 (call (cleavir-ir:make-funcall-instruction
		(list typep-function object type-descriptor-constant)
		(list boolean-value)))
	 (nil-constant (cleavir-ir:make-constant-input 'nil)))
    (cleavir-ir:insert-instruction-before fdefinition instruction)
    (cleavir-ir:insert-instruction-before call instruction)
    (change-class instruction 'cleavir-ir:eq-instruction
		  :inputs (list boolean-value nil-constant)
		  :successors (reverse (cleavir-ir:successors instruction)))))

(defun eliminate-typeq (initial-instruction)
  (let ((visited (make-hash-table :test #'eq))
	(to-process '()))
    (flet ((register (instruction)
	     (push instruction to-process)
	     (setf (gethash instruction visited) t)))
      (register initial-instruction)
      (loop until (null to-process)
	    do (let ((instruction (pop to-process)))
		 (maybe-eliminate instruction)
		 (when (typep instruction 'cleavir-ir:typeq-instruction)
		   (register (cleavir-ir:code instruction)))
		 (loop for successor in (cleavir-ir:successors instruction)
		       do (register successor)))))))
