<!DOCTYPE html> <html lang="EN"> <head> <meta charset="utf-8"> <title>Cleavir Attributes</title> <style>html body{margin:0 auto 0 auto;padding:20px;max-width:1024px;font-family:sans-serif;font-size:14pt;overflow-y:scroll;}html body a{text-decoration:none;}html body a[href]{color:#0055AA;}html body a[href]:hover{color:#0088EE;}html body pre{background:#FAFAFA;border:1px solid #DDDDDD;padding:0.75em;overflow-x:auto;}html body pre >code a[href]{color:#223388;}article.project h1{font-size:1.7em;}article.project h1,article.project h2,article.project h3,article.project h4,article.project h5,article.project h6{margin:0.2em 0 0.1em 0;text-indent:1em;}article.project >header{text-align:center;}article.project >header img.logo{display:block;margin:auto;max-height:170px;}article.project >header h1{display:inline-block;text-indent:0;font-size:2.5em;}article.project >header .version{vertical-align:bottom;}article.project >header .languages{margin-top:-0.5em;text-transform:capitalize;}article.project >header .description{margin:0;}article.project >header .pages{margin-top:0.5em;font-size:1.2em;text-transform:capitalize;}article.project >header .pages a{display:inline-block;padding:0 0.2em;}article.project >section{margin:1em 0 1em 0;}article.project #index >ul{list-style:none;margin:0;padding:0;}article.project .row label{display:inline-block;min-width:8em;}article.project #system .row{display:flex;}article.project #system #dependencies{display:inline;margin:0;padding:0;}article.project #system #dependencies li{display:inline;padding:0 0.2em;}article.project #system #author label{vertical-align:top;}article.project #system #author ul{display:inline-block;margin:0;padding:0;list-style:none;}article.definition{margin:1em 0 0 0;}article.definition >header h1,article.definition >header h2,article.definition >header h3,article.definition >header h4,article.definition >header h5,article.definition >header h6{text-indent:0;display:inline-block;}article.definition >header ul{display:inline-block;list-style:none;margin:0;padding:0;}article.definition >header ul li{display:inline-block;padding:0 0.2em 0 0;}article.definition >header .visibility{display:none;}article.definition >header .visibility,article.definition >header .type{text-transform:lowercase;}article.definition >header .source-link{visibility:hidden;float:right;}article.definition >header .source-link:after{visibility:visible;content:"[SRC]";}article.definition .docstring{margin:0 0 0 1em;}article.definition .docstring pre{font-size:0.8em;white-space:pre-wrap;}.definition.package >header ul.nicknames{display:inline-block;list-style:none;margin:0;padding:0 0 0 1em;}.definition.package >header ul.nicknames li{display:inline;}.definition.package >header ul.nicknames:before{content:"(";}.definition.package >header ul.nicknames:after{content:")";}.definition.package ul.definitions{margin:0;list-style:none;padding:0 0 0 0.5em;}.definition.callable >header .name:before,.definition.type >header .name:before{content:"(";font-weight:normal;}.definition.callable >header .arguments:after,.definition.type >header .arguments:after{content:")";}.definition.callable >header .arguments .arguments:before,.definition.type >header .arguments .arguments:before{content:"(";}.definition.callable >header .arguments .argument,.definition.type >header .arguments .argument{padding:0;}.definition.callable >header .arguments .argument.lambda-list-keyword,.definition.type >header .arguments .argument.lambda-list-keyword{color:#991155;}.definition li>mark{background:none;border-left:0.3em solid #0088EE;padding-left:0.3em;display:block;}</style> </head> <body> <article class="project"> <header>   <h1>cleavir attributes</h1>   <span class="version">1.0.0</span>    <p class="description">Information about values not encompassed by the type system.</p>   </header> <section id="documentation"><p>Data, especially functions, have many properties not expressible
in the CL type system. For example:</p> <ol> <li>whether their arguments can escape</li> <li>whether they call their arguments</li> <li>whether it can be constant folded, and how to do so</li> <li>whether they escape from their defining context</li> <li>how to determine the type of the return values from
   specifically some given argument types</li> <li>how to rewrite a call to be more efficient given type, extent,
   or other information</li> </ol> <p>This subsystem encapsulates this information in an
&quot;attributes&quot; object. These attributes can be stored in the
environment (so that e.g. a compiler knows that AREF has no
side effects) before making their way into ASTs and IR
where they can be used to validate transformations.</p> <p>Attributes have a few differences from types. For the most part
they are impossible to test at runtime. They can be propagated
like types, and sometimes inferred like types, but usually
a meet or join operation won't return information as interesting
as that you might get from a type.</p> <p>For clients: You can use make-attributes to make attributes to
return from CLEAVIR-ENV:FUNCTION-INFO etc.</p> <p>TODO: All of this stuff should be more client-customizable.
Per-argument attributes might be good.</p> <h1 id="flags">Flags</h1> <p>A flag is a binary on-off indicating some known information about a function.</p> <p>Flags are generally organized so that their lack is the general case, i.e. if a flag is &quot;positive&quot; in that it enables transformations, it must be explicitly asserted. Another way of putting this is that a completely unknown function essentially has no flags.</p> <h2 id="currently_available_flags">Currently available flags</h2> <p><code>:NO-CALL</code> means that the function does not increase the number of ways its arguments can be called. That is, it does not call them itself, and does not enable calls to occur in new ways (e.g. by storing an argument in a global variable, where anybody could call it later). This weird phrasing is because function arguments could do these things themselves <code>(e.g. (labels ((foo (x) (push (cons #'foo x) *calls*))) ...))</code> and this does not implicate the NO-CALL-ness of any function that is passed them as an argument.
Implies DYN-CALL.</p> <p><code>:DYN-CALL</code> means that the function can only increase the number of ways its arguments can be called with ways that call the argument in a dynamic environment substantially identical to that of the <code>DYN-CALL</code> function. For example, <code>(lambda (f) (funcall f))</code> could be <code>DYN-CALL</code>, but <code>(lambda (f x) (let ((*x* x)) (funcall f)))</code> could not, as it calls its argument f in a different dynamic environment. This implies that arguments are dx-safe (TODO: attributes for that) because if <code>f</code> was e.g. stored in a global it could later be called in arbitrary dynamic environments.</p> <p><code>:DX-CALL</code> implies that the function's callable arguments do not escape. For example, the function <code>(lambda (f) (funcall f))</code> is <code>DX-CALL</code>, while <code>(lambda (f) f)</code> is not. FIXME: This is probably better expressed as a dynamic extent attribute on individual arguments.</p> <p><code>:FLUSHABLE</code> means the function does not side-effect, and that calls to it can be deleted if the value of the call is not used.</p> </section>   <section id="system"> <h2>System Information</h2>  <div class="row"> <label for="version">Version:</label> <a id="version">1.0.0</a> </div>   <div class="row"> <label for="dependencies">Dependencies:</label> <ul id="dependencies"><li><a class="external" href="https://s-expressionists.github.io/Cleavir/cleavir-io/">cleavir-io</a></li></ul> </div>   <div class="row" id="author"> <label for="author">Authors:</label> <ul> <li><a href="mailto:aeshtaer@gmail.com">Bike</a> </li> </ul> </div>   <div class="row"> <label for="license">License:</label> <a id="license" href="https://tldrlegal.com/search?q=BSD">BSD</a> </div>   <div class="row"> <label for="homepage">Homepage:</label> <a id="homepage" href="https://s-expressionists.github.io/Cleavir/cleavir-attributes/">https://s-expressionists.github.io/Cleavir/cleavir-attributes/</a> </div>   <div class="row"> <label for="sources">Sources:</label> <a id="sources" href="https://github.com/s-expressionists/Cleavir.git">https://github.com/s-expressionists/Cleavir.git</a> </div>  </section>    <section id="index"> <h2>Definition Index</h2> <ul> <li> <article class="definition package" id="PACKAGE CLEAVIR-ATTRIBUTES"> <header> <h3> <a href="#PACKAGE%20CLEAVIR-ATTRIBUTES">CLEAVIR-ATTRIBUTES</a> </h3> <ul class="nicknames"></ul>  </header> <div class="docstring"><i>No documentation provided.</i></div> <ul class="definitions"> <li> <article class="definition class" id="CLASS CLEAVIR-ATTRIBUTES:ATTRIBUTES"> <header> <span class="visibility">EXTERNAL</span> <span class="type">CLASS</span> <h4 class="name"> <a href="#CLASS%20CLEAVIR-ATTRIBUTES%3AATTRIBUTES">ATTRIBUTES</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/s-expressionists/Cleavir/blob/main/Attributes/attributes.lisp">Source</a>  </header> <div class="docstring"><pre>An object representing non-type attributes of a value.</pre></div> </article> </li>  <li> <article class="definition type-definition" id="TYPE CLEAVIR-ATTRIBUTES:ATTRIBUTES-DESIGNATOR"> <header> <span class="visibility">EXTERNAL</span> <span class="type">TYPE-DEFINITION</span> <h4 class="name"> <a href="#TYPE%20CLEAVIR-ATTRIBUTES%3AATTRIBUTES-DESIGNATOR">ATTRIBUTES-DESIGNATOR</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="file:///usr/share/sbcl-source/src/compiler/deftype.lisp#12:0">Source</a>  </header> <div class="docstring"><pre>A designator for an attributes object, usable where an attributes object would be.
NIL means no attributes.
T means all attributes. This will never be the case for any real value, but is useful as a theoretical dual to NIL. It is analogous to the CL:NIL type.

See <a href="#CLASS%20CLEAVIR-ATTRIBUTES%3AATTRIBUTES" class="xref">ATTRIBUTES</a></pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION CLEAVIR-ATTRIBUTES:DEFAULT-ATTRIBUTES"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20CLEAVIR-ATTRIBUTES%3ADEFAULT-ATTRIBUTES">DEFAULT-ATTRIBUTES</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments"></ul>  <a class="source-link" href="https://github.com/s-expressionists/Cleavir/blob/main/Attributes/attributes.lisp">Source</a>  </header> <div class="docstring"><pre>Return the attributes that are safe to assume of any value.</pre></div> </article> </li>  <li> <article class="definition function callable" id="FUNCTION CLEAVIR-ATTRIBUTES:MAKE-FLAGS"> <header> <span class="visibility">EXTERNAL</span> <span class="type">FUNCTION</span> <h4 class="name"> <a href="#FUNCTION%20CLEAVIR-ATTRIBUTES%3AMAKE-FLAGS">MAKE-FLAGS</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument lambda-list-keyword">&amp;REST</li>    <li class="argument">FLAGS</li>  </ul>  <a class="source-link" href="https://github.com/s-expressionists/Cleavir/blob/main/Attributes/flags.lisp">Source</a>  </header> <div class="docstring"><pre>Return computed flags, given a list of flag specifiers (keywords like :NO-CALL).

See <a href="#GENERIC-FUNCTION%20CLEAVIR-ATTRIBUTES%3AHAS-FLAG-P" class="xref">HAS-FLAG-P</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION CLEAVIR-ATTRIBUTES:HAS-FLAG-P"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20CLEAVIR-ATTRIBUTES%3AHAS-FLAG-P">HAS-FLAG-P</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ATTRIBUTES-DESIGNATOR</li>    <li class="argument">FLAG-NAME</li>  </ul>  <a class="source-link" href="https://github.com/s-expressionists/Cleavir/blob/main/Attributes/attributes.lisp">Source</a>  </header> <div class="docstring"><pre>Return true iff the attributes have the given flag on.</pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION CLEAVIR-ATTRIBUTES:IDENTITIES"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20CLEAVIR-ATTRIBUTES%3AIDENTITIES">IDENTITIES</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ATTRIBUTES-DESIGNATOR</li>  </ul>  <a class="source-link" href="https://github.com/s-expressionists/Cleavir/blob/main/Attributes/attributes.lisp">Source</a>  </header> <div class="docstring"><pre>A list of objects used as identifiers for this function. These are used by BIR-TRANSFORMATIONS for client-defined, function-specific transformations, constant folds, type derivations, etc. Their nature is not defined by Cleavir, except that they can be compared with EQUAL, and that they should be externalizable if ASTs are to be externalized.
One easy choice is to use function names.
This is a list to account for data flow. For example, if a datum can originate from two separate definitions with different identities, the lists of identities are merged to reach a combined empty list of identities.

See BIR-TRANSFORMATIONS:TRANSFORM-CALL
See BIR-TRANSFORMATIONS:FOLD-CALL
See BIR-TRANSFORMATIONS:DERIVE-RETURN-TYPE</pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION CLEAVIR-ATTRIBUTES:JOIN-ATTRIBUTES"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20CLEAVIR-ATTRIBUTES%3AJOIN-ATTRIBUTES">JOIN-ATTRIBUTES</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ATTRIBUTES-DESIGNATOR-1</li>    <li class="argument">ATTRIBUTES-DESIGNATOR-2</li>  </ul>  <a class="source-link" href="https://github.com/s-expressionists/Cleavir/blob/main/Attributes/attributes.lisp">Source</a>  </header> <div class="docstring"><pre>Dual to MEET-ATTRIBUTES.

See <a href="#GENERIC-FUNCTION%20CLEAVIR-ATTRIBUTES%3AMEET-ATTRIBUTES" class="xref">MEET-ATTRIBUTES</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION CLEAVIR-ATTRIBUTES:MEET-ATTRIBUTES"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20CLEAVIR-ATTRIBUTES%3AMEET-ATTRIBUTES">MEET-ATTRIBUTES</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ATTRIBUTES-DESIGNATOR-1</li>    <li class="argument">ATTRIBUTES-DESIGNATOR-2</li>  </ul>  <a class="source-link" href="https://github.com/s-expressionists/Cleavir/blob/main/Attributes/attributes.lisp">Source</a>  </header> <div class="docstring"><pre>Return attributes combining both inputs; the returned attributes only have a given quality if both of the inputs do.

See <a href="#GENERIC-FUNCTION%20CLEAVIR-ATTRIBUTES%3AJOIN-ATTRIBUTES" class="xref">JOIN-ATTRIBUTES</a></pre></div> </article> </li>  <li> <article class="definition generic-function callable" id="GENERIC-FUNCTION CLEAVIR-ATTRIBUTES:SUB-ATTRIBUTES-P"> <header> <span class="visibility">EXTERNAL</span> <span class="type">GENERIC-FUNCTION</span> <h4 class="name"> <a href="#GENERIC-FUNCTION%20CLEAVIR-ATTRIBUTES%3ASUB-ATTRIBUTES-P">SUB-ATTRIBUTES-P</a> </h4> <ul class="qualifiers"></ul> <ul class="arguments">  <li class="argument">ATTRIBUTES-DESIGNATOR-1</li>    <li class="argument">ATTRIBUTES-DESIGNATOR-2</li>  </ul>  <a class="source-link" href="https://github.com/s-expressionists/Cleavir/blob/main/Attributes/attributes.lisp">Source</a>  </header> <div class="docstring"><pre>Return true iff attributes-designator-1 is less specific than attributes-designator-2.</pre></div> </article> </li> </ul> </article> </li> </ul> </section>  </article> <script>window.addEventListener("DOMContentLoaded", function(){
    var unmarkElement = function(el){
        if(el.tagName === "mark" || el.tagName === "MARK"){
            [].forEach.call(el.childNodes, function(child){
                el.parentNode.insertBefore(child, el);
            });
            el.parentNode.removeChild(el);
        }else if(el.parentNode.tagName === "mark"){
            return unmarkElement(el.parentNode);
        }
        return null;
    }

    var unmarkAll = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("mark"), unmarkElement);
    }
    
    var markElement = function(el){
        if(el.parentNode.tagName === "mark" || el.parentNode.tagName === "MARK"){
            return el.parentNode;
        } else {
            unmarkAll();
            var marked = document.createElement("mark");
            el.parentNode.insertBefore(marked, el);
            marked.appendChild(el);
            return marked;
        }
    }

    var markFragmented = function(){
        if(window.location.hash){
            var el = document.getElementById(decodeURIComponent(window.location.hash.substr(1)));
            if(el) markElement(el);
        }
    }

    var registerXrefLink = function(link){
        var el = document.getElementById(decodeURIComponent(link.getAttribute("href").substr(1)));
        if(el){
            link.addEventListener("click", function(){
                markElement(el);
            });
        }
    }

    var registerXrefLinks = function(root){
        root = root || document;
        [].forEach.call(root.querySelectorAll("a.xref"), registerXrefLink);
    }

    markFragmented();
    registerXrefLinks();
}); </script> </body> </html> 